# 80x86微处理器

---

## 8086/8088微处理器

8086有16根数据引脚，可以一次存取8位或16位数据；有20根地址引脚，可以直接寻址1M(2^20^)个存储单元和64K个I/O端口。在8086推出后不久，为了方便8位机用户，Inter推出了8088微处理器，其指令系统与8086完全兼容，但外部总线是8位的，这样设计的目的主要是为了与原有的8位外围接口芯片兼容。

![img](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1571843260680&di=c77165704268dfd9b7c4381808706223&imgtype=0&src=http%3A%2F%2Fgss0.baidu.com%2F-Po3dSag_xI4khGko9WTAnF6hhy%2Fzhidao%2Fpic%2Fitem%2F3b292df5e0fe99257f438c5232a85edf8db17161.jpg)

---

### 8086/8088内部结构

8086CPU内部结构框图如图所示，从功能上讲可分为两大类：==总线接口单元BIU==和==执行单元EU==。

![img](http://file.elecfans.com/web1/M00/4F/23/o4YBAFrUJ-yAXkxgAACyEwJLBDA798.jpg)

----

+ 总线接口单元BIU

    总线接口单元BIU的功能是负责完成CPU与存储器或I/O设备之间的数据传送。其具体任务是：

    + 读指令——指令队列出现空字节（8088CPU1个空字节，8086CPU2个空字节）时，从内存取出后续指令。BIU取出指令时，并不影响EU的执行，两者并行工作，大大提高了CPU的执行速度。
    + 读操作数——EU需要从内存或外设端口读取操作数时，根据EU给出的地址或外设端口读取数据供EU使用。
    + 写操作数——EU的执行结果由BIU送往指定的内存单元或外设接口。

    总线接口单元内有4个16位段寄存器，即

    | 简写 | 全称          | 中文名           |
    | ---- | ------------- | ---------------- |
    | CS   | Code Segment  | 代码段寄存器     |
    | DS   | Data Segment  | 数据段寄存器     |
    | SS   | Stack Segment | 堆栈段寄存器     |
    | ES   | Extra Segment | 附加数据段寄存器 |

    一个16位的指针指令寄存器**IP（Instruction Pointer）**，一个20位的地址加法器，一个6字节**指令队列缓冲器**，一个与EU通信的**内部寄存器**以及总线控制电路等。下面对总线接口单元中有关部件的功能作详细介绍。

1. 段寄存器

    ​		8086Cpu的地址引脚有20根，能提供20位的地址信息，可直接对1M个存储单元进行访问，但Cpu内部可用来提供地址信息的寄存器都是16位的，那么如何用16位寄存器实现20位地址的寻址呢?8086/8088采用了**段结构**的内存管理办法。

    ​		将指令代码和数据分别存储在**代码段、数据段、堆栈段、附加数据段**中，这些段的段地址分别由段寄存器CS、DS、SS、ES提供，而代码或数据在段内的偏移地址则由有关寄存器或立即数形式的偏移地址给出。

    | 段寄存器 | 作用                                                         |
    | :------: | :----------------------------------------------------------- |
    |    CS    | 存储程序当前使用的代码段的段地址。代码段用来存放程序的指令代码。下一条要读取指令在代码段中的偏移地址由指令指针寄存器IP提供。 |
    |    DS    | 存放程序当前使用的数据段的段地址。一般来说，程序中所用到的原始数据、中间结果以及最终结果都存放在数据段中。如果程序中使用了字符串处理指令，则源字符串也存放在数据段中。 |
    |    SS    | 存放程序当前所使用的堆栈段的段地址。堆栈是在存储器中开辟的一个特定区域。 |
    |    ES    | 存放程序当前使用的附加数据段的段地址。附加数据段通常用于存放字符串操作时的目的字符串。 |

    程序员在编写汇编语言的源程序时，应该按照上述规定将程序的各个部分放在规定的段内。每个源程序必须至少有一个代码段，而其他则根据程序的需要决定是否设置。

2. 指令指针寄存器

    指令指针寄存器IP用来存放吓一跳要读取的指令在代码段中的偏移地址。IP在程序运行中能自动加1修正，从而使其始终存放的是下一条要读取的指令在代码段的偏移地址。由于CS和IP的内容决定了程序的执行顺序，因此程序员不能直接用赋值指令对其内容进行修改。有些指令能使IP和CS的值改变（如跳转指令）或使其值压入堆栈或从堆栈中弹出恢复原值（如子程序调用指令和返回指令）。

3. 20位地址加法器

    ​		8086/8088CPU在对存储单元进行访问以读取指令或读/写操作数时，必须在地址总线上提供20位的地址信息，以便选中对应的存储单元。

    1. 逻辑地址：

        其表达形式为：“段地址：段内偏移地址”。段内偏移地址又称为“有效地址”（EA，Effective Address）。在读指令时，段地址有代码段寄存器CS提供，当前要读取指令在代码段中的偏移地址由指令指针寄存器IP提供；在读取或存储操作数时，根据具体操作，段地址由DS、ES或SS提供，段内偏移地址由指令给出。

    2. 物理地址：

        CPU与存储器进行数据交换时在地址总线上提供的20位地址信息称为物理地址。由逻辑地址求物理地址的公式为：

        物理地址 = 段地址 × 10H + 段内偏移地址

        假设当前（CS）= 20A8H，（IP）= 2008H，那么，下一条从内存中读取的指令所在的存储单元的物理地址为**20A8H × 10H + 2008H = 22A88H**。

4. 指令队列缓冲器

    8086的指令队列有6个字节，8088的指令队列有4个字节。当指令队列出现2个空字节（对8086而言）或1个空字节（对8088而言）BIU就自动执行一次取指令周期，将下一条要执行的指令从内存单元读入指令队列。它们采用“先进先出”的原则，按顺序存放，并按顺序取到EU中去执行。

    当EU执行跳转、子程序调用或返回指令时，BIU就使指令队列复位，并从指令给出的新地址开始取指令，新取的第一条指令直接经指令队列送EU执行，随后取来的指令将填入指令队列缓冲器。

    指令队列的引入使得EU和BIU可并行工作，即BIU在读指令时，并不影响EU单元执行指令，EU单元可以连续不断地直接从指令队列中取到要执行的指令代码，从而减少了CPU为取指令而等待的时间，提高了CPU的利用率，加快了整机的运行速度。

+ 执行单元EU

    执行单元EU不与系统外部直接相连，它的功能只是负责执行指令。执行的指令从BIU的指令队列缓冲器中直接得到。执行指令时若需要从存储器或I/O端口读写操作数，由EU向BIU发出请求，再由BIU对存储器或I/O端口进行访问。EU由下列部件组成：

    	+ 16位算术逻辑单元（ALU）：用于进行算数和逻辑运算。
    	+ 16位标志寄存器FLAGS：用来存放CPU运算结果的状态特征和控制标志。
    	+ 数据暂存寄存器：协助ALU完成运算，暂存参加运算的数据。
    	+ 通用寄存器：包括4个16位数据寄存器AX、BX、CX、DX和4个16位指针与变址寄存器SP、BP与SI、DI。
    	+ EU控制电路：它是控制、定时与状态逻辑电路，接收从BIU中指令队列取来的指令，经过指令译码形成各种定时控制信号，对EU的各个部件实现特定的定时操作。

    8088CPU内部结构与8086基本相似，两者的执行单元EU完全相同，其指令系统、寻址方式及程序设计方式都相同，所以两种CPU完全兼容。区别仅在于总线接口单元BIU，归纳起来主要有以下几个方面的差异：

    + 外部数据总线位数不同。8086外部数据总线为16位，在一个总线周期内可以输入/输出一个字（16位数据）；而8088外部数据总线为8位，在一个总线周期内只能输入/输出一个字节（8位数据）。
    + 指令队列缓冲器大小不同。8086指令队列可容纳6个字节，且在每一个总线周期中从存储器取出2个字节的指令代码填入指令队列；而8088指令队列只能容纳4个字节，在一个机器周期中取出一个字节的指令代码送指令队列。
    + 部分引脚的功能定义有所区别。

-----

### 8086/8088寄存器结构

8086/8088CPU内部有14个16位寄存器，按功能可分为三大类：通用寄存器（8个）、段寄存器（4个）和控制寄存器（2个）。

![image-20191028193001744](C:\Users\Yankfu\AppData\Roaming\Typora\typora-user-images\image-20191028193001744.png)

#### 通用寄存器

通用寄存器包括4个数据寄存器、两个地址指针寄存器和两个变址寄存器。

1. 数据寄存器AX、BX、CX、DX

    数据寄存器一般用于存放参与运算的操作数或运算结果。每个数据寄存器都是16位的，但又可将高、低8位分别作为两个独立的8位寄存器来用。高8位分别记为AH、BH、CH、DH，低8位分别记作AL、BL、C、DL。例如AX可当作两个8位寄存器AH、AL使用。注意，8086/8088CPU的14个寄存器除了这4个16位寄存器能分别当作两个8位寄存器来用之外，其他寄存器都不能如此使用。

    上述4个寄存器一般用来存放数据，但它们各自都有自己的特定用途：

    AX（Accumulator）称为累加器。用改寄存器存放运算结果可使指令简化，提高指令的执行速度。此外，所有I/O指令都使用该寄存器与外设端口交换信息。

    BX（Base）称为基址寄存器。8086/8088CPU中有两个基址寄存器BX和BP。BX用来存放操作数在内存中数据段内的偏移地址，BP用来存放操作数在堆栈段内的偏移地址。

    CX（Counter）称为计数器。在设计循环程序时使用该寄存器存放循环次数，可使程序指令简化，有利于提高程序的运行速度。

    DX（Data）称为数据寄存器。在寄存器间接寻址的I/O指令中存放I/O端口地址；在作双字长乘除法运算时，DX与AX一起存放一个双字长操作数，其中DX存放高16位数。

2. 地址指针寄存器SP、BP

     SP（Stack Pointer）称为堆栈指针寄存器。在使用堆栈操作指令（PUSH或POP）对堆栈进行操作时，每执行一次进栈或出栈操作，系统会自动将SP的内容减2或加2

    ，以使其始终指向栈顶。

    BP（Base Pointer）称为基址寄存器。作为通用寄存器，它可以用来存放数据，但更更重要的用途是存放操作数在堆栈段内的偏移地址。

3. 变址寄存器SI、DI

    SI（Source Index）称为源变址寄存器。DI（Destination Index）称为目的变址寄存器。这两个寄存器通常用在字符串操作时存放操作数的偏移地址，其中SI存放源串在数据段内的偏移地址，DI存放目的串在附加数据段内的偏移地址。

#### 段寄存器

为了对1M个存储单元进行管理，8086/8088对存储器进行分段管理，即将程序代码或数据分别放在代码段、数据段、堆栈段或附加数据段中，每个段最多可达64K个存储单元。段地址分别放在对应的段寄存器中，代码或数据在段内的偏移地址由有关寄存器或立即数给出。8086/8088的四个段寄存器分别为：

CS（Code Segment）称为代码段寄存器，用来存储程序当前使用的代码段的段地址。CS的内容左移4位再加上指令指针寄存器IP的内容就是下一条要读取的指令在存储器中的物理地址。

DS（Data Segment）称为数据段寄存器，用来存放程序当前使用的数据段的段地址。DS的内容左移4位再加上按指令中存储器寻址方式给出的偏移地址即得到对数据段指定单元进行读写的物理地址。

SS（Stack Segment）称为堆栈段寄存器，用来存放程序当前所使用的堆栈段的段地址。堆栈是存储器中开辟的按“先进后出”原则组织的一个特殊存储区，主要用于调用子程序或执行中断服务程序时保护断点和现场。

ES（Extra Segment）称为附加数据段寄存器，用来存放程序当前使用的附加数据段的段地址。附加数据段用来存放字符串操作时的目的字符串。

在8086/8088系统中，段寄存器和与其对应的存放段内偏移地址的寄存器之间有一种默认组合关系，如表所示：

| 段寄存器 | 提供段内偏移地址的寄存器                 |
| -------- | ---------------------------------------- |
| CS       | IP                                       |
| DS       | BX、SI、DI或一个16位立即数形式的偏移地址 |
| SS       | SP或BP                                   |
| ES       | DI（用于字符串操作指令）                 |

在这种默认组合下，指令中不必专门指定其组合关系，但指令如用到非默认的组合关系，则必须用段超越前缀加以说明。

#### 控制寄存器

IP（Instruction Pointer）称为指令指针寄存器，用来存放下一条要读取的指令在代码段内的偏移地址。用户程序不能直接访问IP。

FLAGS称为标志寄存器，它是一个16位的寄存器，但只用了其中9位，这9位包括6个状态标志位和3个控制标志位，如图所示。

|      |      |      |      | OF   | DF   | IF   | TF   | SF   | ZF   |      | AF   |      | PF   |      | CF   |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 15   |      |      |      | 11   | 10   | 9    | 8    | 7    | 6    |      | 4    |      | 2    |      | 0    |

控制标志位：TF、IF、DF

状态标志位：CF、PF、AF、ZF、SF、OF

1. 状态标志位

    CF（Carry Flag）——进位标志位。

    PF（Parity Flag）——奇偶标志位。

    AF（Auxiliary Flag）——辅助进位标志位。

    ZF（Zero Flag）——零标志位。

    SF（Sign Flag）——符号标志为。

    OF（Overflow Flag）——溢出标志位。

2. 控制标志位

    控制标志位有3个，用来控制CPU的操作，由程序设置或清除。它们是：

    TF（Trap Flag）——跟踪（陷阱）标志位。

    IF（Interrupt Flag）——中断允许标志位。它是用来控制可屏蔽中断的控制标志位。

    DF（Direction Flag）——方向标志位。

